const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const bodyParser = require('body-parser');
const path = require('path');
const config = require('./config');

// Import routes
const paymentRoutes = require('./routes/payment');
const webhookRoutes = require('./routes/webhook');

const app = express();
const PORT = config.server.port;

// Generate nonce for CSP first
app.use((req, res, next) => {
  res.locals.nonce = require('crypto').randomBytes(16).toString('base64');
  next();
});

// Security middleware with dynamic CSP
app.use((req, res, next) => {
  helmet({
    contentSecurityPolicy: {
      directives: {
        ...helmet.contentSecurityPolicy.getDefaultDirectives(),
        "script-src": ["'self'", `'nonce-${res.locals.nonce}'`],
        "script-src-attr": [`'nonce-${res.locals.nonce}'`],
      },
    },
  })(req, res, next);
});

// CORS configuration
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? [config.domain.url] 
    : ['http://localhost:3000', 'http://127.0.0.1:3000'],
  credentials: true
}));

// Body parsing middleware
app.use(bodyParser.json({ limit: '10mb' }));
app.use(bodyParser.urlencoded({ extended: true, limit: '10mb' }));

// Serve static files
app.use(express.static(path.join(__dirname, 'public')));

// API Routes
app.use('/api/payment', paymentRoutes);
app.use('/api/webhook', webhookRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    environment: config.server.nodeEnv,
    domain: config.domain.url
  });
});

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    message: 'NodeJS Coin Payment Service',
    description: 'PayID19.com integration for cryptocurrency payments',
    domain: config.domain.url,
    endpoints: {
      health: '/health',
      createInvoice: '/api/payment/create-invoice',
      getInvoices: '/api/payment/invoices',
    }
  });
});

// Payment success page
app.get('/payment/success', async (req, res) => {
  console.log('Payment success page');
  console.log('Request data:', {
    query: req.query,
    body: req.body,
    params: req.params,
    headers: req.headers,
    cookies: req.cookies,
    ip: req.ip,
    method: req.method,
    url: req.originalUrl
  });
  const { order_id, invoice_id, status, return_url } = req.query;
  
  // Handle URL encoding issues - check for malformed return_url parameter
  let actualReturnUrl = return_url;
  if (!actualReturnUrl) {
    // Check for the malformed parameter that appears as 'amp;return_url'
    const malformedKey = Object.keys(req.query).find(key => key.includes('return_url'));
    if (malformedKey) {
      actualReturnUrl = req.query[malformedKey];
      console.log('Found malformed return_url parameter:', malformedKey, '=', actualReturnUrl);
    }
  }
  
  // Determine the return URL - prioritize return_url parameter, fallback to root
  let returnUrl = actualReturnUrl || '/';
  
  console.log('Success page redirect info:', {
    return_url,
    actualReturnUrl,
    returnUrl,
    hasReturnUrl: !!return_url,
    hasActualReturnUrl: !!actualReturnUrl,
    willShowRedirect: returnUrl && returnUrl !== '/'
  });
  
  // Use the nonce generated by middleware
  const nonce = res.locals.nonce;
  
  // If we have order_id but no invoice_id, try to fetch invoice information
  let finalOrderId = order_id;
  let finalInvoiceId = invoice_id;
  let finalStatus = status;
  
  if (order_id && !invoice_id) {
    try {
      console.log(`üîç Success page: Fetching invoice information for order_id: ${order_id}`);
      const PayID19Service = require('./services/PayID19Service');
      const payid19Service = new PayID19Service();
      const invoiceResult = await payid19Service.getInvoices(order_id);
      
      console.log(`üìã Success page: Invoice API result:`, {
        success: invoiceResult.success,
        hasData: !!invoiceResult.data,
        dataType: Array.isArray(invoiceResult.data) ? 'array' : typeof invoiceResult.data,
        dataLength: Array.isArray(invoiceResult.data) ? invoiceResult.data.length : 'not array',
        error: invoiceResult.error
      });
      
      if (invoiceResult.success && invoiceResult.data) {
        const invoiceData = Array.isArray(invoiceResult.data) ? invoiceResult.data[0] : invoiceResult.data;
        console.log(`üìÑ Success page: Invoice data:`, {
          hasInvoiceData: !!invoiceData,
          invoice_id: invoiceData?.invoice_id,
          id: invoiceData?.id,
          order_id: invoiceData?.order_id,
          status: invoiceData?.status
        });
        
        if (invoiceData) {
          finalInvoiceId = invoiceData.invoice_id || invoiceData.id;
          console.log(`‚úÖ Success page: Set finalInvoiceId to: ${finalInvoiceId}`);
          if (!finalStatus) {
            finalStatus = invoiceData.status;
            console.log(`‚úÖ Success page: Set finalStatus to: ${finalStatus}`);
          }
        } else {
          console.log(`‚ùå Success page: No invoice data found`);
        }
      } else {
        console.log(`‚ùå Success page: API call failed:`, {
          success: invoiceResult.success,
          error: invoiceResult.error,
          message: invoiceResult.message
        });
        
        // Try to extract invoice information from the error field
        if (invoiceResult.error) {
          try {
            // The error might be a JSON string containing invoice data
            let invoiceDataFromError = null;
            
            if (typeof invoiceResult.error === 'string') {
              // Try to parse as JSON array first (common format)
              if (invoiceResult.error.startsWith('[') && invoiceResult.error.endsWith(']')) {
                const parsedArray = JSON.parse(invoiceResult.error);
                if (Array.isArray(parsedArray) && parsedArray.length > 0) {
                  invoiceDataFromError = parsedArray[0];
                }
              }
              // Try to parse as JSON object
              else if (invoiceResult.error.startsWith('{') && invoiceResult.error.endsWith('}')) {
                invoiceDataFromError = JSON.parse(invoiceResult.error);
              }
            } else if (typeof invoiceResult.error === 'object') {
              invoiceDataFromError = invoiceResult.error;
            }
            
            if (invoiceDataFromError) {
              console.log(`üìÑ Success page: Extracted invoice data from error:`, {
                hasInvoiceData: !!invoiceDataFromError,
                alias: invoiceDataFromError?.alias,
                id: invoiceDataFromError?.id,
                order_id: invoiceDataFromError?.order_id,
                status: invoiceDataFromError?.status
              });
              
              // Use alias as invoice_id if available, fallback to id
              finalInvoiceId = invoiceDataFromError.alias || invoiceDataFromError.id;
              if (finalInvoiceId) {
                console.log(`‚úÖ Success page: Extracted finalInvoiceId from error: ${finalInvoiceId}`);
              }
              
              // Also extract status if not already set
              if (!finalStatus && invoiceDataFromError.status) {
                finalStatus = invoiceDataFromError.status;
                console.log(`‚úÖ Success page: Extracted finalStatus from error: ${finalStatus}`);
              }
            }
          } catch (parseError) {
            console.error('‚ùå Success page: Error parsing invoice data from error field:', parseError);
          }
        }
      }
    } catch (error) {
      console.error('‚ùå Success page: Error fetching invoice information:', error);
    }
  } else {
    console.log(`üìã Success page: Parameters received:`, {
      order_id,
      invoice_id,
      status,
      hasOrderId: !!order_id,
      hasInvoiceId: !!invoice_id,
      hasStatus: !!status,
      willFetchFromAPI: !!(order_id && !invoice_id)
    });
  }
  
  // Update return URL to include invoice_id if we have it and it's a custom return URL
  if (finalInvoiceId && returnUrl && returnUrl !== '/') {
    const separator = returnUrl.includes('?') ? '&' : '?';
    returnUrl = `${returnUrl}${separator}invoice_id=${encodeURIComponent(finalInvoiceId)}`;
    console.log(`‚úÖ Success page: Updated return URL with invoice_id: ${returnUrl}`);
  }
  
  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Payment Successful</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
        .success { color: #28a745; }
        .container { background: #f8f9fa; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .details { background: white; padding: 20px; margin: 20px 0; border-radius: 5px; }
        .btn { display: inline-block; padding: 10px 20px; background: #28a745; color: white; text-decoration: none; border-radius: 5px; margin-top: 20px; cursor: pointer; border: none; }
        .btn:hover { background: #1e7e34; }
        .redirect-info { background: #d4edda; padding: 15px; margin: 20px 0; border-radius: 5px; border-left: 4px solid #28a745; }
        .countdown { font-weight: bold; color: #28a745; }
      </style>
    </head>
    <body>
      <div class="container">
        <h1 class="success">‚úÖ Payment Successful!</h1>
        <p>Your cryptocurrency payment has been processed successfully.</p>
        <div class="details">
          <p><strong>Order ID:</strong> ${finalOrderId || 'N/A'}</p>
          <p><strong>Invoice ID:</strong> ${finalInvoiceId || 'N/A'}</p>
          <p><strong>Status:</strong> ${finalStatus || 'Completed'}</p>
        </div>
        <p>Thank you for your payment!</p>
        ${returnUrl && returnUrl !== '/' ? `
          <div class="redirect-info">
            <p>üîÑ Automatically redirecting you back to the application in <span id="countdown" class="countdown">5</span> seconds...</p>
          </div>
          <button id="redirectBtn" class="btn" nonce="${nonce}">Return to Application Now</button>
        ` : `
          <a href="${returnUrl}" class="btn">Continue</a>
        `}
      </div>
      ${returnUrl && returnUrl !== '/' ? `
        <script nonce="${nonce}">
          let countdown = 5;
          const countdownElement = document.getElementById('countdown');
          const redirectBtn = document.getElementById('redirectBtn');
          const returnUrl = '${returnUrl}';
          
          const redirectTimer = setInterval(() => {
            countdownElement.textContent = countdown;
            countdown--;
            if (countdown < 0) {
              clearInterval(redirectTimer);
              window.location.href = returnUrl;
            }
          }, 1000);
          
          redirectBtn.addEventListener('click', function() {
            clearInterval(redirectTimer);
            window.location.href = returnUrl;
          });
        </script>
      ` : ''}
    </body>
    </html>
  `);
});

// Payment cancel page
app.get('/payment/cancel', async (req, res) => {
  console.log('Payment cancel page');
  console.log(req.query);
  const { order_id, invoice_id, return_url } = req.query;
  
  // Handle URL encoding issues - check for malformed return_url parameter
  let actualReturnUrl = return_url;
  if (!actualReturnUrl) {
    // Check for the malformed parameter that appears as 'amp;return_url'
    const malformedKey = Object.keys(req.query).find(key => key.includes('return_url'));
    if (malformedKey) {
      actualReturnUrl = req.query[malformedKey];
      console.log('Found malformed return_url parameter:', malformedKey, '=', actualReturnUrl);
    }
  }
  
  // Determine the return URL - prioritize return_url parameter, fallback to root
  let returnUrl = actualReturnUrl || '/';
  
  console.log('Cancel page redirect info:', {
    return_url,
    actualReturnUrl,
    returnUrl,
    hasReturnUrl: !!return_url,
    hasActualReturnUrl: !!actualReturnUrl,
    willShowRedirect: returnUrl && returnUrl !== '/'
  });
  
  // Use the nonce generated by middleware
  const nonce = res.locals.nonce;
  
  // If we have order_id but no invoice_id, try to fetch invoice information
  let finalOrderId = order_id;
  let finalInvoiceId = invoice_id;
  
  if (order_id && !invoice_id) {
    try {
      console.log(`üîç Cancel page: Fetching invoice information for order_id: ${order_id}`);
      const PayID19Service = require('./services/PayID19Service');
      const payid19Service = new PayID19Service();
      const invoiceResult = await payid19Service.getInvoices(order_id);
      
      console.log(`üìã Cancel page: Invoice API result:`, {
        success: invoiceResult.success,
        hasData: !!invoiceResult.data,
        dataType: Array.isArray(invoiceResult.data) ? 'array' : typeof invoiceResult.data,
        dataLength: Array.isArray(invoiceResult.data) ? invoiceResult.data.length : 'not array',
        error: invoiceResult.error
      });
      
      if (invoiceResult.success && invoiceResult.data) {
        const invoiceData = Array.isArray(invoiceResult.data) ? invoiceResult.data[0] : invoiceResult.data;
        console.log(`üìÑ Cancel page: Invoice data:`, {
          hasInvoiceData: !!invoiceData,
          invoice_id: invoiceData?.invoice_id,
          id: invoiceData?.id,
          order_id: invoiceData?.order_id
        });
        
        if (invoiceData) {
          finalInvoiceId = invoiceData.invoice_id || invoiceData.id;
          console.log(`‚úÖ Cancel page: Set finalInvoiceId to: ${finalInvoiceId}`);
        } else {
          console.log(`‚ùå Cancel page: No invoice data found`);
        }
      } else {
        console.log(`‚ùå Cancel page: API call failed:`, {
          success: invoiceResult.success,
          error: invoiceResult.error,
          message: invoiceResult.message
        });
        
        // Try to extract invoice information from the error field
        if (invoiceResult.error) {
          try {
            // The error might be a JSON string containing invoice data
            let invoiceDataFromError = null;
            
            if (typeof invoiceResult.error === 'string') {
              // Try to parse as JSON array first (common format)
              if (invoiceResult.error.startsWith('[') && invoiceResult.error.endsWith(']')) {
                const parsedArray = JSON.parse(invoiceResult.error);
                if (Array.isArray(parsedArray) && parsedArray.length > 0) {
                  invoiceDataFromError = parsedArray[0];
                }
              }
              // Try to parse as JSON object
              else if (invoiceResult.error.startsWith('{') && invoiceResult.error.endsWith('}')) {
                invoiceDataFromError = JSON.parse(invoiceResult.error);
              }
            } else if (typeof invoiceResult.error === 'object') {
              invoiceDataFromError = invoiceResult.error;
            }
            
            if (invoiceDataFromError) {
              console.log(`üìÑ Cancel page: Extracted invoice data from error:`, {
                hasInvoiceData: !!invoiceDataFromError,
                alias: invoiceDataFromError?.alias,
                id: invoiceDataFromError?.id,
                order_id: invoiceDataFromError?.order_id
              });
              
              // Use alias as invoice_id if available, fallback to id
              finalInvoiceId = invoiceDataFromError.alias || invoiceDataFromError.id;
              if (finalInvoiceId) {
                console.log(`‚úÖ Cancel page: Extracted finalInvoiceId from error: ${finalInvoiceId}`);
              }
            }
          } catch (parseError) {
            console.error('‚ùå Cancel page: Error parsing invoice data from error field:', parseError);
          }
        }
      }
    } catch (error) {
      console.error('‚ùå Cancel page: Error fetching invoice information:', error);
    }
  } else {
    console.log(`üìã Cancel page: Parameters received:`, {
      order_id,
      invoice_id,
      hasOrderId: !!order_id,
      hasInvoiceId: !!invoice_id,
      willFetchFromAPI: !!(order_id && !invoice_id)
    });
  }
  
  // Update return URL to include invoice_id if we have it and it's a custom return URL
  if (finalInvoiceId && returnUrl && returnUrl !== '/') {
    const separator = returnUrl.includes('?') ? '&' : '?';
    returnUrl = `${returnUrl}${separator}invoice_id=${encodeURIComponent(finalInvoiceId)}`;
    console.log(`‚úÖ Cancel page: Updated return URL with invoice_id: ${returnUrl}`);
  }
  
  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Payment Cancelled</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
        .cancel { color: #dc3545; }
        .container { background: #f8f9fa; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .details { background: white; padding: 20px; margin: 20px 0; border-radius: 5px; }
        .btn { display: inline-block; padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; margin-top: 20px; cursor: pointer; border: none; }
        .btn:hover { background: #0056b3; }
        .redirect-info { background: #e7f3ff; padding: 15px; margin: 20px 0; border-radius: 5px; border-left: 4px solid #007bff; }
        .countdown { font-weight: bold; color: #007bff; }
      </style>
    </head>
    <body>
      <div class="container">
        <h1 class="cancel">‚ùå Payment Cancelled</h1>
        <p>Your payment has been cancelled.</p>
        <div class="details">
          <p><strong>Order ID:</strong> ${finalOrderId || 'N/A'}</p>
          <p><strong>Invoice ID:</strong> ${finalInvoiceId || 'N/A'}</p>
        </div>
        <p>You can try again or contact support if you need assistance.</p>
        ${returnUrl && returnUrl !== '/' ? `
          <div class="redirect-info">
            <p>üîÑ Automatically redirecting you back to the application in <span id="countdown" class="countdown">3</span> seconds...</p>
          </div>
          <button id="redirectBtn" class="btn" nonce="${nonce}">Return to Application Now</button>
        ` : `
          <a href="${returnUrl}" class="btn">Return to Home</a>
        `}
      </div>
      ${returnUrl && returnUrl !== '/' ? `
        <script nonce="${nonce}">
          let countdown = 3;
          const countdownElement = document.getElementById('countdown');
          const redirectBtn = document.getElementById('redirectBtn');
          const returnUrl = '${returnUrl}';
          
          const redirectTimer = setInterval(() => {
            countdownElement.textContent = countdown;
            countdown--;
            if (countdown < 0) {
              clearInterval(redirectTimer);
              window.location.href = returnUrl;
            }
          }, 1000);
          
          redirectBtn.addEventListener('click', function() {
            clearInterval(redirectTimer);
            window.location.href = returnUrl;
          });
        </script>
      ` : ''}
    </body>
    </html>
  `);
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Error:', err.stack);
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong!'
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    error: 'Not Found',
    message: `Route ${req.method} ${req.path} not found`
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ NodeJS Coin Payment Service running on port ${PORT}`);
  console.log(`üåê Domain: ${config.domain.url}`);
  console.log(`üìä Environment: ${config.server.nodeEnv}`);
  console.log(`üí∞ PayID19 API: ${config.payid19.apiUrl}`);
});

module.exports = app;
